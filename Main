import com.opencsv.*;
import java.lang.Math;

import java.util.*;
import java.io.*;
public class Main {
    public static void main(String[] args) {


        //command line file grabber
       /*
        if((args.length) != 2){
            System.out.printf("Invalid number of arguments: %d given, needs 2.\n\nProvide input and output file name", args.length);

        }


        else
        {
            //grab from command line
            String pathToCsv=args[1];
        }
        */

        LinkedList<LinkedList<String[]>> LLParent = new LinkedList<>();

        int ID=0;
        try {
            String pathToCsv = "RSSI.csv";
            BufferedReader csvReader = new BufferedReader(new FileReader(pathToCsv));


            String row;
            while ((row = csvReader.readLine()) != null) {
                String[] data = row.split(",");

                //holds tuple
                String[] xy = {data[1], data[2]};
                String[] tempxy = new String[2];




                int beaconNum;
                //loops through .csv row starting from 4th position
                for (int i = 3; i < data.length - 1; i++) {
                    int match = 0;
                    beaconNum = i;
                    int done=0;
                    int j = 0;
                    //if value is filtered, ignore


                    //if you want to filter values <|85|, do so in this conditional statement
                    if (data[i].equals("\"-1000\""))
                    {
                        //System.out.println("filter is active: " + data[i]);

                    }
                    else{
                        //System.out.println("filter is inactive: " + data[i]);

                        while (LLParent.size()>j) {
                                /*
                                if (LLParent.get(j).size()==0){
                                    continue;
                                } */

                                //System.out.printf("j is :%d \nLLparent size is %d\n",j, LLParent.size());
                                tempxy[0] = LLParent.get(j).get(0)[1];
                                tempxy[1] = LLParent.get(j).get(0)[2];



                            //if the x and y coords of the data
                            if (tempxy[0].equals(xy[0]) && tempxy[1].equals(xy[1])) {
                                match = 1;
                                break;
                            }

                            j++;
                        }





                        //if there is a match
                        if (match == 1) {
                            //check if the significant column is populated

                            for (int k = 0; k < LLParent.get(j).size(); k++) {
                                //if there is an open spot in any of the previously made lists... add it!
                                if (LLParent.get(j).get(k)[beaconNum]== null) {
                                    LLParent.get(j).get(k)[beaconNum] = data[beaconNum];
                                    done = 1;
                                    break;
                                }
                            }

                            if (done==0) {


                                String[] stringo = new String[36];
                                stringo[0] = Integer.toString(ID);
                                stringo[1] = tempxy[0];
                                stringo[2] = tempxy[1];
                                stringo[beaconNum] = data[beaconNum];

                                //append string to llchild for more room
                                LLParent.get(j).add(stringo);
                            }


                        }
                        //if not a match
                        else {
                            //make new linked list corresponding to new (x,y)
                            LinkedList<String[]> list = new LinkedList<>();
                            LLParent.add(list);
                            //generate array that will be first element in the new linked list, populate it
                            String[] dataRow = new String[36];
                            ID++;
                            //System.out.println(xy[0]);
                            dataRow[0] = Integer.toString(ID);
                            dataRow[1] = xy[0];
                            dataRow[2] = xy[1];
                            dataRow[beaconNum] = data[beaconNum];
                            LLParent.getLast().add(dataRow);

                            //The corresponding (x,y) pair now has its own linked list, which has one element containing the first iteration of the (x,y) pair
                        }

                    }

                }
                //get (x, y)
                //get beaconData (find value that's not -1000)
                //traverse LLParent to find (x, y) match
                // CASE 1 - no match, make new LLChild, insert beaconData
                // CASE 2 - yes match (x, y), no match beacon, insert beaconData
                // CASE 3 - yes match (x, y), yes match beacon, make new LLChild, insert beaconData


            }


            //make .csv



            System.out.println(LLParent.get(0).get(0)[0]);
            CSVWriter writer = new CSVWriter(new FileWriter("output.csv"));

            //header goes here...
            //String header = "x,y"
            //for loop up to 36 that appends ",\"i\"" to the end of the string



            for (LinkedList<String[]> LLchild : LLParent) {

                for (String[] string : LLchild) {
                    int n=0;



                    int skipcounter=0;
                    for (String i : string) {





                        //skip... check against original dataset
                        if (skipcounter==1 || skipcounter==2){


                        string[n]="nope";
                        skipcounter++;
                        continue;
                    }
                        skipcounter++;



                        if (i!=null) {

                            string[n] = i.replace("\"", "");

                        }
                        else {
                            string[n] = "-1000";
                        }
                        double rssi = Integer.parseInt(string[n]);
                        //the man in question
                        rssi= (-9.315* -Math.log(-rssi))-40.253;
                        string[n]= Double.toString(rssi);
                        n++;
                    }

                    writer.writeNext(string);
                }

            }


            csvReader.close();


        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}






/*
NOTES:
linked list going down
linked list going sideways
if array exists at xy location, insert beacon
if beacon reading exists, make new array
if no array, make new array
*/



